<!doctype html>
<html lang="en">
	<script src="https://code.iconify.design/iconify-icon/1.0.8/iconify-icon.min.js"></script>
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/x-icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/app.CuxvBB9u.css" rel="stylesheet">
		<link href="../_app/immutable/assets/Footer.CgORz9JN.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.V2TXjpPM.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.DMaFa41j.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DlMPQ7kW.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CucvcyUy.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CQ4v2ukt.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.D_Kg2Hd5.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CWj6FrbW.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/YaY44Lv3.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.DkchpZiJ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BESi_VYH.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.CvsibAwl.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CPJJShKr.js"><!--[--><meta name="description" content=""/><!--]--><title>&lt;Brian Hill's FloppySite></title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><!----><!----><a href="/projects"><button class="fixed top-4 left-4 text-sm px-4 py-2 rounded hover:bg-cyan-100 transition">← Back</button></a> <div class="bg-neutral-100 font-mono px-4 py-12 min-h-screen"><section class="max-w-4xl mx-auto"><h1 class="text-4xl font-bold mb-2">The Smallest EFI Engine (that I know of)</h1> <p class="text-sm text-gray-500 mb-6">2025-08-28</p> <div class="content space-y-6 text-base text-neutral-800 leading-relaxed"><!----><p>A couple of years ago, I was given the remains of a weed eater which had been designated as garbage, and for some reason I thought I would rescue the engine from the body. This engine ended up being a <a href="https://www.troybilt.com/en_US/prior-year-models/tb635-ec-curved-shaft-string-trimmer/41ADZ63C766.html">TroyBilt TB635EC</a> – one of the most unreliable engines from one of the most unreliable brands. I decided I wanted I before I knew what to do with it, so I threw it on a shelf for half a decade. Fast forward to a couple of months ago, I was replacing a <a href="https://en.wikipedia.org/wiki/Carburetor">carburetor</a> on another weed eater with my dad and I thought to myself “wouldn’t this be cool if it was fuel injected?” It turns out that yes, yes indeed it is cool, but it is also a massive pain in the ass.</p>
<p>Before we get to far in, yes I know the title is technically wrong, but only slightly. There are currently no commercial sub-35cc engines which are fuel injected. Mostly because this entire project is stupid, but that’s besides the point. There are <em>technically</em> small nitro and gasoline <a href="https://en.wikipedia.org/wiki/Fuel_injection">Electronic Fuel Injection (EFI)</a> engines which exist for specialized miniature aircraft. This is not really comparable, as this is a conversion and is also being designed using a commercial block in mind. I’m just going to pretend that it is the smallest displacement EFI engine and you should too since it makes this write up more entertaining and has a better motivation than just screwing around.</p>
<p>Now, if are reading this like a normal, non-engine nerd person, you are probably really confused by everything in that last part. Don’t worry, the rest of this will contain much better explanations than that above, I just had to get rid of some of “well acktually” people before they email me with their comments. But as a starting point, let me start by introducing the main reasons and features of this engine and how they work.</p>
<p>The TroyBilt TB635EC (which I will now refer to as just ‘the engine’ from now on) is a single cylinder 30cc <a href="https://en.wikipedia.org/wiki/Four-stroke_engine">four stroke</a> engine. From the factory, it makes a whopping two horsepower, uses a single carburetor with a plastic external choke, and <a href="https://en.wikipedia.org/wiki/Capacitor_discharge_ignition">Capacitive Discharge Ignition (CDI)</a> system. The rear of the engine has a small cooling fan, pull start, and drill clutch starter (which we will discuss in a moment), while the front has a simple high speed <a href="https://en.wikipedia.org/wiki/Centrifugal_clutch">centrifugal clutch</a>. </p>
<p>Upon seeing these specs, I get excited, as these are very normal for small displacement engines, except for one thing: it’s a four stroke. A four stroke engine is complicated, but to understand what this means in the context of this engine, just understand that this is the same process larger engines (cars, trucks, planes, etc.) use. Now, in the context of this story and why I did this, this is the most important initial detail. If this was not a four stroke I would not have done this at all. The fact that this is a four stroke engine means that I have references in the form of production motor vehicles that I can use. Of course, this is much different, but some of the principles still exist. </p>
<p>EFI engines need a few things different to a carbureted engine which make them different. Carbureted engines have historically been used as they are cheap, manually operated, and work on physics principles alone. They work by using air pressure differences to atomize fuel from a venturi and combine it with air in the optimal ratio. EFI uses a computer and many sensors to inject fuel through, well, a fuel injector – thus the name. The core idea of this project is to replace this mechanical fueling system with electronics in order to run or improve the performance of the engine. I will set my sights on simply running it for now, as improving performance will be difficult for reasons we will discuss soon. </p>
<p>To begin this project the first thing we need is a plan, and in my case the plan was to first run the carbureted engine as normal and get some data. Running the engine normally, the max speed the engine reached was ~9300 RPM. This was tuned and running with the same fuel the EFI system would use. I had planned to use a generator connected tot he drive shaft, but a lot of reasons prevented me from being able to connect the two systems and generate electricity without stalling the engine. My generator was from a Elliptical, and thus has a flywheel attached, and thus max RPM became the metric the engine would be compared against. </p>
<img src="https://i.imgur.com/W1TYYiq.jpeg" alt="carbureted engine setup" />

<p>I should stop here to note that this is not a perfect metric by any means, but I think it’s good enough as there is no way in this case to measure torque and the valve springs (a possible limiting factor) should be rated for significantly higher speeds.</p>
<p>After determining the ‘goal,’ my first target was to figure out how to get information from the engine. The first target I had was the simplest: RPM. My idea to get the output speed of the engine was to use a hall effect sensor. This is a very common way to do this in modern technology, and we use hall sensors in things from joysticks to actual production engines. The <a href="https://en.wikipedia.org/wiki/Hall_effect_sensor">Hall Effect</a> is the principle that a magnetic field applied perpendicular to a conductor can cause a change in current within the conductor. This has been condensed and packaged into a small chip which we can pair with the already attached magnets on the flywheel of the engine to get our RPM. There were some hiccups with this idea however, as the hall effect sensor I chose was analogue which I thought would be fine, but surprise, <strong>it was very much not fine</strong>. I ended up having to switch from the Pi Pico’s <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">ADC</a> to a GPIO pin with a interrupt and a comparator (LM311P) to get everything to work – something that took a while for me to diagnose and develop. I should also mention that once I had a RPM reading, I threw on a basic 128x64 OLED display which ran over I2C (the SSD1306) so I would have a readout without a laptop.</p>
<p>Once I had engine RPM, I knew I needed a way to fire the injector and I needed a way to know both when to fire it and with how much fuel. In terms of hardware, these problems actually turned out to be relatively trivial. To fire the injector, I knew I needed 12V (which I also needed for a fuel pump) and I knew I wanted to switch it with a MOSFET. I chose to use a IRLZ44N to switch that, and a 2N2222 to switch that in order to prevent a default on state when the microcontroller starts up. If I had not done this, startup would compose of spraying fuel everywhere and starting a possible fire, thus safety was chosen. </p>
<p>To detect when to fire the injector and with how much fuel, I initially chose to use a <a href="https://en.wikipedia.org/wiki/Mass_flow_sensor">Mass Airflow Sensor (MAF)</a>, however, I was quickly told off by the internet as I would not have enough airflow for any commercial sensor. I thus chose a <a href="https://en.wikipedia.org/wiki/MAP_sensor">Manifold Absolute Pressure (MAP)</a> sensor, and while I would still have the same issues, it was still usable in the short term. This sensor gives the air pressure, and with a bit of math can be used to get the airflow and the ideal amount of fuel to deliver to get the ideal <a href="https://en.wikipedia.org/wiki/Air%E2%80%93fuel_ratio">stoichiometric ratio</a> of fuel to air for a proper burn. This value was then converted into time in microseconds that the injector was open for (a duty cycle). I also added a control knob, to live tune the amount of fuel being injected for the test as this was done in the field and I didn’t want to hardcode a fuel map if I didn’t know the precision of the system and sensors.</p>
<p>I also added a couple of extra sensors in the form of <a href="">thermistors</a>, though I ended up removing them for reasons we will soon discuss. I should also mention that the thermistors and knob were analogue as well, and the injector was fired via digital GPIO.</p>
<img src="https://i.imgur.com/uo7acNn.png" alt="schematic" />

<p>Now is probably a good time to mention the microcontroller I chose to use: the Pi Pico. No surprise here, it’s my favorite microcontroller, and for a lot of reasons, I seriously regret choosing it for this project. Or at least, I should have never used the onboard ADC system it has. For those of you not super technically inclined, I apologize for this section and the technicality it has, and I recommend skipping this part. The onboard ADC system is slow. So slow, I cannot in good faith recommend using it. I can however, recommend using <a href="https://en.wikipedia.org/wiki/Direct_memory_access">Direct Memory Access (DMA)</a> to grab the values of the ADC without a lot of overhead. The only downside, is that I cannot, after asking multiple people for help, figure out why three channels does not work. It should. The SDK and documentation say so. Others say it should. I’ve yet to meet anyone who’s actually used it with DMA, and surprise surprise, it doesn’t work. In fact, not only does it not work, it cause so much overhead when trying to read with a <strong>slightly</strong> high buffer size (of &gt;300 – 256 works fine) that my I2C display will stop initializing and the Pi itself will crash due to a blocking call from the DMA interrupt. </p>
<p>I understand that you may be thinking that this is my code fault I need to be better – and yes, that is true. But the code I have published is actually a significantly earlier revision I had working with two channels, as adding a third lead me to entirely rewrite the program to maximize the DMA/ADC read cycle only and it still did not work. So, I figured the engine is likely to never really get hot, so I decided to simply remove the thermistors and call it a day. This ended up being a sound decision, as the stress of this was not worth it in the slightest.</p>
<p>After all of that, I then wired everything up using this overcomplicated system of connectors to make the entire thing modular. This is something I may discuss in a future entry, as I feel a breakout board with a common interface (maybe JST connectors?) which could be used to extend the Pico without soldering and allow custom sensor modules would be extremely beneficial and would have reduced this project’s soldering time significantly. Regardless, once the hardware was done and some safety switches and relays were added, I designed a intake manifold (which is probably my most proud of part I have ever designed for how beautiful it turned out after printing) and some supports. I bolted my engine to to a 2x6, placed some bags of shot for weight, added a fuel pump and fuel reservoir, ran some wires, got multiple power supplies (I hate large inductive loads), and set everything up to go. </p>
<p>Something I failed to mention earlier is that the engine itself has the ignition assembly and throttle assembly already mounted. I chose reuse the carburetor as a throttle body as it was the perfect size and used the same bolt pattern I needed for the connection to the engine anyways. For ignition, I couldn’t use the pull start system (and wouldn’t want to anyways) so I lucked out when I found out <a href="">TroyBilt makes a drill attachment starter bit for turning over engines safely</a>. All of these things together with some non-ethanol fuel and a oil change meant the engine was ready to go.</p>
<img src="https://i.imgur.com/RiwCIPs.jpeg" alt="efi setup" />

<p>As you can see in the picture, the setup looks rough. That being said, it does work. The engine fires up (after some coercion) and hits ~9300 RPM – the same as the carbureted setup. It has a little bit better throttle response, but is less reliable as the vacuum pulled by the piston is low enough that the MAP sensor sometimes misses the intake event. This could be solved by a properly sized MAP sensor, but ideally a camshaft position sensor would fix this. Of course, the cam shaft is completely inaccessible on this engine, so that’s not really a possibility, but it’s the thought that counts. If I were to do this again, I would 100% buy a thrashed motorcycle engine to do this on. That way I could both have a real engine with mounting points (maybe even a frame and wheels so I can give a more quantitative analysis) and a lot more sensors. The TroyBilt just doesn’t have the scale to support much work. I would also up the budget a bunch and simply weld brackets for this. It’s kind of lame that the entire thing is stuck to a 2x6 and I would prefer it higher off the ground.</p>
<p>I should also mention that this took me three months to do. Mostly because the entire debug/troubleshooting process was a slog. It was either a hardware issue or a software issue or a fuel issue or a power issue – you get the point. It was always something and when I found a solution, there was always two more problems to greet me. I was also really not comfortable with the fuel situation. I was using a tupperware with a taped down fuel filter and EFI fuel pump as a fuel tank, sending 58psi of fuel pressure to some scuffed fittings which had a 50/50 chance of shooting fuel everywhere. I was afraid a fire would start, which is part of the reason I stopped recording tests with my camera and instead brought a fire extinguisher. That, combined with the absolute drag it was having to unplug my Pico, run upstairs and make a change to the code, compile and move it to the Pico, run back down only to find out it doesn’t work, and then do it again. The entire process stopped being fun and any idea I had about making a video on the process was lost in the scuffle.</p>
<img src="https://i.imgur.com/79QjpmZ.jpeg" alt="'fuel tank'" />

<p>This was a really interesting project. I feel like I couldn’t do it justice fully. Partially due to costs – not having a better microcontroller and decent sensors (as well as a decent engine to work on to begin with) were major sticking points and I feel like I could have done this better with an extra $300. Realistically, I should have gone down to my local scrapyard and got a engine out of a trashed Toyota Corolla and brought that home to work on. I also a big limitation was my ability to code this. If I could do this again, I would use a <a href="https://en.wikipedia.org/wiki/STM32">STM32 microcontroller</a> and have a custom PCB made for the sensor breakout and power management. Not having to deal with as many hardware issues would have made this easier to deal with. Essentially, only having one front to fight would have made this more fun. </p>
<p>The engine performed about how I realistically expected it to – maybe even a bit better. As confident as I may have sounded discussing the plan, my expectations were significantly lower. The result was fine for what I wanted it to be. The limitation was probably my code or simply that valve springs (but probably my code). Moral of the story, don’t bite off more than you can chew, otherwise a fun project might turn in to something much more of a drag then you could want. This project felt like I had to learn a lot to be able to do it as well, which is difficult to wrap my head around. In a sense, I knew what I wanted to do, how I wanted to do it, and what I needed to do to make it happen, but every issue I encountered took my far outside my current knowledge base in a way that I was not learning about how engines work or how ECUs work, but moreso how a specific feature of the Pi Pico works and how to program around it. </p>
<p>That’s all I have to say about this project. It was real. It was fun. Actually it was not that fun. Maybe at first. But certainly not real fun.</p>
<p>Until next time.</p>
<!----></div></section></div> <div><footer class="bg-black text-neutral-600 w-full h-[4em] flex flex-col items-center justify-center px-4 font-mono"><div class="flex gap-4 mt-1"><p class="text-sm">Made With Floppy Disks • ©2025 Brian Hill •</p> <!--[--><a href="https://github.com/TrojanPinata" target="_blank" rel="noopener noreferrer" aria-label="GitHub" class="text-lg hover:text-gray-400 transition-colors"><iconify-icon icon="mdi:github" class="svelte-upsgr"></iconify-icon></a><a href="https://www.linkedin.com/in/brian-hill-0082161a3/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn" class="text-lg hover:text-gray-400 transition-colors"><iconify-icon icon="mdi:linkedin" class="svelte-upsgr"></iconify-icon></a><a href="mailto:hillbr20@gmail.com" target="_blank" rel="noopener noreferrer" aria-label="Email" class="text-lg hover:text-gray-400 transition-colors"><iconify-icon icon="mdi:email" class="svelte-upsgr"></iconify-icon></a><!--]--></div></footer></div><!----><!----><!----><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_5st61e = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.DMaFa41j.js"),
						import("../_app/immutable/entry/app.D_Kg2Hd5.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [null,{type:"data",data:{meta:{title:"The Smallest EFI Engine (that I know of)",date:"2025-08-28"},content:"\u003Cp>A couple of years ago, I was given the remains of a weed eater which had been designated as garbage, and for some reason I thought I would rescue the engine from the body. This engine ended up being a \u003Ca href=\"https://www.troybilt.com/en_US/prior-year-models/tb635-ec-curved-shaft-string-trimmer/41ADZ63C766.html\">TroyBilt TB635EC\u003C/a> – one of the most unreliable engines from one of the most unreliable brands. I decided I wanted I before I knew what to do with it, so I threw it on a shelf for half a decade. Fast forward to a couple of months ago, I was replacing a \u003Ca href=\"https://en.wikipedia.org/wiki/Carburetor\">carburetor\u003C/a> on another weed eater with my dad and I thought to myself “wouldn’t this be cool if it was fuel injected?” It turns out that yes, yes indeed it is cool, but it is also a massive pain in the ass.\u003C/p>\n\u003Cp>Before we get to far in, yes I know the title is technically wrong, but only slightly. There are currently no commercial sub-35cc engines which are fuel injected. Mostly because this entire project is stupid, but that’s besides the point. There are \u003Cem>technically\u003C/em> small nitro and gasoline \u003Ca href=\"https://en.wikipedia.org/wiki/Fuel_injection\">Electronic Fuel Injection (EFI)\u003C/a> engines which exist for specialized miniature aircraft. This is not really comparable, as this is a conversion and is also being designed using a commercial block in mind. I’m just going to pretend that it is the smallest displacement EFI engine and you should too since it makes this write up more entertaining and has a better motivation than just screwing around.\u003C/p>\n\u003Cp>Now, if are reading this like a normal, non-engine nerd person, you are probably really confused by everything in that last part. Don’t worry, the rest of this will contain much better explanations than that above, I just had to get rid of some of “well acktually” people before they email me with their comments. But as a starting point, let me start by introducing the main reasons and features of this engine and how they work.\u003C/p>\n\u003Cp>The TroyBilt TB635EC (which I will now refer to as just ‘the engine’ from now on) is a single cylinder 30cc \u003Ca href=\"https://en.wikipedia.org/wiki/Four-stroke_engine\">four stroke\u003C/a> engine. From the factory, it makes a whopping two horsepower, uses a single carburetor with a plastic external choke, and \u003Ca href=\"https://en.wikipedia.org/wiki/Capacitor_discharge_ignition\">Capacitive Discharge Ignition (CDI)\u003C/a> system. The rear of the engine has a small cooling fan, pull start, and drill clutch starter (which we will discuss in a moment), while the front has a simple high speed \u003Ca href=\"https://en.wikipedia.org/wiki/Centrifugal_clutch\">centrifugal clutch\u003C/a>. \u003C/p>\n\u003Cp>Upon seeing these specs, I get excited, as these are very normal for small displacement engines, except for one thing: it’s a four stroke. A four stroke engine is complicated, but to understand what this means in the context of this engine, just understand that this is the same process larger engines (cars, trucks, planes, etc.) use. Now, in the context of this story and why I did this, this is the most important initial detail. If this was not a four stroke I would not have done this at all. The fact that this is a four stroke engine means that I have references in the form of production motor vehicles that I can use. Of course, this is much different, but some of the principles still exist. \u003C/p>\n\u003Cp>EFI engines need a few things different to a carbureted engine which make them different. Carbureted engines have historically been used as they are cheap, manually operated, and work on physics principles alone. They work by using air pressure differences to atomize fuel from a venturi and combine it with air in the optimal ratio. EFI uses a computer and many sensors to inject fuel through, well, a fuel injector – thus the name. The core idea of this project is to replace this mechanical fueling system with electronics in order to run or improve the performance of the engine. I will set my sights on simply running it for now, as improving performance will be difficult for reasons we will discuss soon. \u003C/p>\n\u003Cp>To begin this project the first thing we need is a plan, and in my case the plan was to first run the carbureted engine as normal and get some data. Running the engine normally, the max speed the engine reached was ~9300 RPM. This was tuned and running with the same fuel the EFI system would use. I had planned to use a generator connected tot he drive shaft, but a lot of reasons prevented me from being able to connect the two systems and generate electricity without stalling the engine. My generator was from a Elliptical, and thus has a flywheel attached, and thus max RPM became the metric the engine would be compared against. \u003C/p>\n\u003Cimg src=\"https://i.imgur.com/W1TYYiq.jpeg\" alt=\"carbureted engine setup\" />\n\n\u003Cp>I should stop here to note that this is not a perfect metric by any means, but I think it’s good enough as there is no way in this case to measure torque and the valve springs (a possible limiting factor) should be rated for significantly higher speeds.\u003C/p>\n\u003Cp>After determining the ‘goal,’ my first target was to figure out how to get information from the engine. The first target I had was the simplest: RPM. My idea to get the output speed of the engine was to use a hall effect sensor. This is a very common way to do this in modern technology, and we use hall sensors in things from joysticks to actual production engines. The \u003Ca href=\"https://en.wikipedia.org/wiki/Hall_effect_sensor\">Hall Effect\u003C/a> is the principle that a magnetic field applied perpendicular to a conductor can cause a change in current within the conductor. This has been condensed and packaged into a small chip which we can pair with the already attached magnets on the flywheel of the engine to get our RPM. There were some hiccups with this idea however, as the hall effect sensor I chose was analogue which I thought would be fine, but surprise, \u003Cstrong>it was very much not fine\u003C/strong>. I ended up having to switch from the Pi Pico’s \u003Ca href=\"https://en.wikipedia.org/wiki/Analog-to-digital_converter\">ADC\u003C/a> to a GPIO pin with a interrupt and a comparator (LM311P) to get everything to work – something that took a while for me to diagnose and develop. I should also mention that once I had a RPM reading, I threw on a basic 128x64 OLED display which ran over I2C (the SSD1306) so I would have a readout without a laptop.\u003C/p>\n\u003Cp>Once I had engine RPM, I knew I needed a way to fire the injector and I needed a way to know both when to fire it and with how much fuel. In terms of hardware, these problems actually turned out to be relatively trivial. To fire the injector, I knew I needed 12V (which I also needed for a fuel pump) and I knew I wanted to switch it with a MOSFET. I chose to use a IRLZ44N to switch that, and a 2N2222 to switch that in order to prevent a default on state when the microcontroller starts up. If I had not done this, startup would compose of spraying fuel everywhere and starting a possible fire, thus safety was chosen. \u003C/p>\n\u003Cp>To detect when to fire the injector and with how much fuel, I initially chose to use a \u003Ca href=\"https://en.wikipedia.org/wiki/Mass_flow_sensor\">Mass Airflow Sensor (MAF)\u003C/a>, however, I was quickly told off by the internet as I would not have enough airflow for any commercial sensor. I thus chose a \u003Ca href=\"https://en.wikipedia.org/wiki/MAP_sensor\">Manifold Absolute Pressure (MAP)\u003C/a> sensor, and while I would still have the same issues, it was still usable in the short term. This sensor gives the air pressure, and with a bit of math can be used to get the airflow and the ideal amount of fuel to deliver to get the ideal \u003Ca href=\"https://en.wikipedia.org/wiki/Air%E2%80%93fuel_ratio\">stoichiometric ratio\u003C/a> of fuel to air for a proper burn. This value was then converted into time in microseconds that the injector was open for (a duty cycle). I also added a control knob, to live tune the amount of fuel being injected for the test as this was done in the field and I didn’t want to hardcode a fuel map if I didn’t know the precision of the system and sensors.\u003C/p>\n\u003Cp>I also added a couple of extra sensors in the form of \u003Ca href=\"\">thermistors\u003C/a>, though I ended up removing them for reasons we will soon discuss. I should also mention that the thermistors and knob were analogue as well, and the injector was fired via digital GPIO.\u003C/p>\n\u003Cimg src=\"https://i.imgur.com/uo7acNn.png\" alt=\"schematic\" />\n\n\u003Cp>Now is probably a good time to mention the microcontroller I chose to use: the Pi Pico. No surprise here, it’s my favorite microcontroller, and for a lot of reasons, I seriously regret choosing it for this project. Or at least, I should have never used the onboard ADC system it has. For those of you not super technically inclined, I apologize for this section and the technicality it has, and I recommend skipping this part. The onboard ADC system is slow. So slow, I cannot in good faith recommend using it. I can however, recommend using \u003Ca href=\"https://en.wikipedia.org/wiki/Direct_memory_access\">Direct Memory Access (DMA)\u003C/a> to grab the values of the ADC without a lot of overhead. The only downside, is that I cannot, after asking multiple people for help, figure out why three channels does not work. It should. The SDK and documentation say so. Others say it should. I’ve yet to meet anyone who’s actually used it with DMA, and surprise surprise, it doesn’t work. In fact, not only does it not work, it cause so much overhead when trying to read with a \u003Cstrong>slightly\u003C/strong> high buffer size (of &gt;300 – 256 works fine) that my I2C display will stop initializing and the Pi itself will crash due to a blocking call from the DMA interrupt. \u003C/p>\n\u003Cp>I understand that you may be thinking that this is my code fault I need to be better – and yes, that is true. But the code I have published is actually a significantly earlier revision I had working with two channels, as adding a third lead me to entirely rewrite the program to maximize the DMA/ADC read cycle only and it still did not work. So, I figured the engine is likely to never really get hot, so I decided to simply remove the thermistors and call it a day. This ended up being a sound decision, as the stress of this was not worth it in the slightest.\u003C/p>\n\u003Cp>After all of that, I then wired everything up using this overcomplicated system of connectors to make the entire thing modular. This is something I may discuss in a future entry, as I feel a breakout board with a common interface (maybe JST connectors?) which could be used to extend the Pico without soldering and allow custom sensor modules would be extremely beneficial and would have reduced this project’s soldering time significantly. Regardless, once the hardware was done and some safety switches and relays were added, I designed a intake manifold (which is probably my most proud of part I have ever designed for how beautiful it turned out after printing) and some supports. I bolted my engine to to a 2x6, placed some bags of shot for weight, added a fuel pump and fuel reservoir, ran some wires, got multiple power supplies (I hate large inductive loads), and set everything up to go. \u003C/p>\n\u003Cp>Something I failed to mention earlier is that the engine itself has the ignition assembly and throttle assembly already mounted. I chose reuse the carburetor as a throttle body as it was the perfect size and used the same bolt pattern I needed for the connection to the engine anyways. For ignition, I couldn’t use the pull start system (and wouldn’t want to anyways) so I lucked out when I found out \u003Ca href=\"\">TroyBilt makes a drill attachment starter bit for turning over engines safely\u003C/a>. All of these things together with some non-ethanol fuel and a oil change meant the engine was ready to go.\u003C/p>\n\u003Cimg src=\"https://i.imgur.com/RiwCIPs.jpeg\" alt=\"efi setup\" />\n\n\u003Cp>As you can see in the picture, the setup looks rough. That being said, it does work. The engine fires up (after some coercion) and hits ~9300 RPM – the same as the carbureted setup. It has a little bit better throttle response, but is less reliable as the vacuum pulled by the piston is low enough that the MAP sensor sometimes misses the intake event. This could be solved by a properly sized MAP sensor, but ideally a camshaft position sensor would fix this. Of course, the cam shaft is completely inaccessible on this engine, so that’s not really a possibility, but it’s the thought that counts. If I were to do this again, I would 100% buy a thrashed motorcycle engine to do this on. That way I could both have a real engine with mounting points (maybe even a frame and wheels so I can give a more quantitative analysis) and a lot more sensors. The TroyBilt just doesn’t have the scale to support much work. I would also up the budget a bunch and simply weld brackets for this. It’s kind of lame that the entire thing is stuck to a 2x6 and I would prefer it higher off the ground.\u003C/p>\n\u003Cp>I should also mention that this took me three months to do. Mostly because the entire debug/troubleshooting process was a slog. It was either a hardware issue or a software issue or a fuel issue or a power issue – you get the point. It was always something and when I found a solution, there was always two more problems to greet me. I was also really not comfortable with the fuel situation. I was using a tupperware with a taped down fuel filter and EFI fuel pump as a fuel tank, sending 58psi of fuel pressure to some scuffed fittings which had a 50/50 chance of shooting fuel everywhere. I was afraid a fire would start, which is part of the reason I stopped recording tests with my camera and instead brought a fire extinguisher. That, combined with the absolute drag it was having to unplug my Pico, run upstairs and make a change to the code, compile and move it to the Pico, run back down only to find out it doesn’t work, and then do it again. The entire process stopped being fun and any idea I had about making a video on the process was lost in the scuffle.\u003C/p>\n\u003Cimg src=\"https://i.imgur.com/79QjpmZ.jpeg\" alt=\"'fuel tank'\" />\n\n\u003Cp>This was a really interesting project. I feel like I couldn’t do it justice fully. Partially due to costs – not having a better microcontroller and decent sensors (as well as a decent engine to work on to begin with) were major sticking points and I feel like I could have done this better with an extra $300. Realistically, I should have gone down to my local scrapyard and got a engine out of a trashed Toyota Corolla and brought that home to work on. I also a big limitation was my ability to code this. If I could do this again, I would use a \u003Ca href=\"https://en.wikipedia.org/wiki/STM32\">STM32 microcontroller\u003C/a> and have a custom PCB made for the sensor breakout and power management. Not having to deal with as many hardware issues would have made this easier to deal with. Essentially, only having one front to fight would have made this more fun. \u003C/p>\n\u003Cp>The engine performed about how I realistically expected it to – maybe even a bit better. As confident as I may have sounded discussing the plan, my expectations were significantly lower. The result was fine for what I wanted it to be. The limitation was probably my code or simply that valve springs (but probably my code). Moral of the story, don’t bite off more than you can chew, otherwise a fun project might turn in to something much more of a drag then you could want. This project felt like I had to learn a lot to be able to do it as well, which is difficult to wrap my head around. In a sense, I knew what I wanted to do, how I wanted to do it, and what I needed to do to make it happen, but every issue I encountered took my far outside my current knowledge base in a way that I was not learning about how engines work or how ECUs work, but moreso how a specific feature of the Pi Pico works and how to program around it. \u003C/p>\n\u003Cp>That’s all I have to say about this project. It was real. It was fun. Actually it was not that fun. Maybe at first. But certainly not real fun.\u003C/p>\n\u003Cp>Until next time.\u003C/p>\n"},uses:{params:["slug"]}}],
							form: null,
							error: null,
							remote: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>